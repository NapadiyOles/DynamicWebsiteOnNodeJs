const data = {
    greedy: "Жадібні Алгоритми - це алгоритмічна парадигма, яка вибудовує рішення рішення шматок за шматком, завжди вибирючи наступний шматок, який несе в собі найбільшу вигоду. Отже, проблема в якій вибір є локально оптимальним також є глобальним рішенням, що є найбільш оптимальним для Жадібного Алгоритму. Для прикладу візьмемо задачу пакування рюкзака. Локально оптимальною стратегією буде вибирати річ, яка має максимальне відношення вартості до ваги. Ця стратегія також є глобально оптимальним рішенням тому, що дозволяє брати частину речі.",
    dynamic: "Динамічне програмування - це переважно оптимізація, порівняно з простою рекурсією. Там, де використовується рекурсивне рішення, що постійно повторює виклики функції, ми можемо оптимізувати це, використовуючи динамічне програмування. Його ідея - зберігати результати підзадач, так що нам не потрібно їх перераховувати, якщо вони знадобляться нам пізніше. Ця проста оптимізація зменшує час роботи з експоненціального до поліноміального. Наприклад, якщо ми пишимо рекурсивне рішення для чисел Фібоначі, ми отримаємо екпоненціальний час, але якщо ми це оптимізуємо за допомогою збереження результатів кожної підзадачі, цей час можна скоротити до лінійного.",
    divide: "Розділяй і володарюй - це алгоритмічна парадигма. Цей метод вирішує задачі трьома кроками: розподіл задачі на підзадачі, рекурсивне вирішення підзадач, об'єднання результатів. Звичайним прикладом розділяй і володарюй є сортування злиттям. В цьому алгоритмі ми ділимо масив на 2 половини, сортуємо їх рекурсивно і об'єднуємо.",
    return: "Алгоритми з поверненням - це техніка алгоритму для рішення проблем рекурсивно, намагаючись побудувати рішення з приростом, одна частина за раз, викидаючи ті рішення, що не можуть задовільнити обмеження проблеми в будь-який момент часу(під часом мають на увазі минувший до досягення будь-якого рівня дерева пошуку час). Наприклад, розглянемо рішення задачі Судоку. Ми намагаємося записувати цифри один за одним. Якщо з'ясовується, що ця цифра не підходить для рішення, ми прибираємо її і шукаємо іншу підходящу цифру. Це краще, ніж наївний підхід (генерація усіх можливих комбінацій цифр та підстановка кожної комбінації один за одним), оскільки це відкидає набір перестановок кожен раз, коли вертається.",
    branch: "Метод гілок та меж - це парадигма проектування алгоритмів, що зазвичай використовується для рішення комбінаторні оптимізаційні задачі. Ці задачі в основному вирішуються за експоненціальний час і перевіряє усі можливі перетворення у найгіршому випадку. Метод гілок та меж вирішує такі задачі відносно швидко. Візьмемо, наприклад, проблему пакування рюкзака, щоб зрозуміти принцип роботи алгоритму гілок та меж. Є декілька алгоритмів, що дозволяють вирішити дану задачу: Жадібний алгоритм, Алгоритм розділяй та володарюй, Метод гілок та меж. Розв'язання методом гілок та меж: Рішення цієї задачі можна оптимізувати, знаючи, яке піддерево найкращого рішення може бути прив'язано до кожного вузла. Якщо найкраще рішення у піддереві гірше за поточне рішення, ми можемо легко проігнорувати цей вузол і його піддерева. Таким чином ми можемо порахувати найкращий розв'язок для кожного вузла і порівняти його з поточним перед дослідженням вузла."
}

document.getElementById("greedy").onclick = (e) => getInfo(e);
document.getElementById("dynamic").onclick = (e) => getInfo(e);
document.getElementById("divide").onclick = (e) => getInfo(e);
document.getElementById("return").onclick = (e) => getInfo(e);
document.getElementById("branch").onclick = (e) => getInfo(e);

function getInfo(e){ e.preventDefault();
    let result;
    console.log(e);
    switch(e.target.id){
        case 'greedy':
            result = data.greedy;
            break;
        case 'dynamic':
            result = data.dynamic;
            break;
        case 'divide':
            result = data.divide;
            break;
        case 'return':
            result = data.return;
            break;
        case 'branch':
            result = data.branch;
            break;
        default:
            result = '';
    }
    document.getElementById('info').innerHTML = result; 
}
